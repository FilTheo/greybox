% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rmc.R
\name{rmc}
\alias{rmc}
\title{RMC test}
\usage{
rmc(data, value = c("normal", "absolute", "squared"), level = 0.95,
  sort = TRUE, style = c("mcb", "lines"), select = NULL, plot = TRUE,
  ...)
}
\arguments{
\item{data}{Matrix or data frame with observations in rows and variables in
columns.}

\item{value}{Type of the provided value. If this is a clear forecast error,
then \code{"normal"} is appropriate, leading to a simple Gausian linear
regression. \code{"absolute"} would lead to truncated regression (if the
package "truncreg" is installed. Otherwise this will be a linear regression).
Finally, \code{"squared"} would lead to the glm with Gamma distribution.}

\item{level}{The width of the confidence interval. Default is 0.95.}

\item{sort}{If \code{TRUE} function sorts the final values of mean ranks.
If plots are requested via \code{type} parameter, then this is forced to
\code{TRUE}.}

\item{style}{What style of plot to use after the calculations. This can be
either "MCB" style or "Vertical lines" one.}

\item{select}{What column of data to highlight on the plot. If NULL, then
the method with the lowest value is selected.}

\item{plot}{If \code{TRUE} then the graph is produced after the calculations.
You can also use plot method on the produced object in order to get the same
effect.}

\item{...}{Other parameters passed to plot function}
}
\value{
If \code{plot=TRUE}, then the function plots the results after all
the calculations. In case of \code{value="normal"}, the closer to zero the
intervals are, the better model performs. When \code{value="absolute"} or
\code{value="squared"}, the smaller, the better.

Function returns a list of a class "rmc", which contains the following
variables:
\itemize{
\item{mean}{Mean values for each method.}
\item{interval}{Confidence intervals for each method.}
\item{p.value}{ANOVA test p-value.}
\item{level}{Significance level.}
\item{model}{lm model produced for the calculation of the intervals.}
\item{style}{Style of the plot to produce.}
\item{select}{The selected variable to highlight.}
}
}
\description{
RMC stands for "Regression for Methods Comparison". This is a parametric
test for the comparison of means of several distributions
This test is a parametric counterpart of nemenyi / MCB test and uses
asymptotic properties of regression models. It relies on distributional
assumptions about the provided data. For instance, if the mean forecast errors
are used, then it is safe to assume that the regression model constructed on
them will have normally distributed residuals.
}
\details{
The test constructs the regression model of the kind:

y = b' X + e,

where y is the vector of the provided data (as.vector(data)), X is the matrix
of dummy variables for each column of the data (forecasting method), b is the
vector of coefficients for the dummies and e is the error term of the model.

Depending on the provided data, it might make sense to use different types of
regressions. The function supports Gausian linear regression
(\code{value="normal"}, when the data is normal), truncated normal linear
regression (\code{value="absolute"}, when \code{truncreg} package is installed,
when the data is truncated normal, for example, absolute errors) and generalised
regression with Gamma distribution (\code{value="squared"}, when the data is
distributed as Chi^2, for example squared errors).

The advisable error measures to use in the test are RelMAE and RelMSE, which are
unbiased and asymptotically have log-normal distribution. Don't forget to take
logarythms of these measures first, in order to impose normality. See examples
for more details on how to do that.

The test is equivalent to nemenyi test, when applied to the ranks of the error
measures on large samples.
}
\examples{
N <- 50
M <- 4
ourData <- matrix(rnorm(N*M,mean=0,sd=1), N, M)
ourData[,2] <- ourData[,2]+1
ourData[,3] <- ourData[,3]+0.7
ourData[,4] <- ourData[,4]+0.5
colnames(ourData) <- c("Method A","Method B","Method C - long name","Method D")
rmc(ourData, value="n", level=0.95)
par(mar=c(2,0,2,0),cex=1.5)
rmc(ourData, level=0.95)

# In case of AE-based measures, value="a" should be selected
rmc(abs(ourData), value="a", level=0.95)

# In case of SE-based measures, value="s" should be selected
rmc(ourData^2, value="s", level=0.95)

# APE-based measures should not be used in general...

# If RelMAE or RelMSE is used for measuring data, then it makes sense to use
# value="n" and provide logarithms of the RelMAE, which will have asymptotic
# normal distribution
ourData <- abs(ourData)
ourData <- ourData / ourData[,1]
rmc(ourData, value="n", level=0.95)

# The following example should give similar results to nemenyi test on
# large samples, which compares medians of the distributions:
rmc(t(apply(ourData,1,rank)), value="n", level=0.95)

}
\references{
\itemize{
\item  Demsar, J. (2006). Statistical Comparisons of Classifiers over
Multiple Data Sets. Journal of Machine Learning Research, 7, 1-30.
\url{http://www.jmlr.org/papers/volume7/demsar06a/demsar06a.pdf}
}
}
\author{
Ivan Svetunkov, \email{ivan@svetunkov.ru}
}
\keyword{htest}
